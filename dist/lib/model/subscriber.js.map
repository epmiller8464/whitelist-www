{"version":3,"sources":["../../../lib/model/subscriber.js"],"names":["mongoose","require","Schema","encrypt","decrypt","module","exports","moment","schema","email","type","String","trim","unique","lowercase","required","minLength","get","v","set","verified","Boolean","default","subscribedTo","unsubscribeFrom","unsubscribeAll","meta","Types","Object","collection","index","Model","model","e"],"mappings":"AAAA;AACA;;AAEA,IAAIA,WAAWC,QAAQ,UAAR,CAAf;AACA,IAAIC,SAASF,SAASE,MAAtB;;eAC2BD,QAAQ,WAAR,C;IAApBE,O,YAAAA,O;IAASC,O,YAAAA,O;;AAChBC,OAAOC,OAAP,GAAiB,YAAY;AAC3B,MAAMC,SAASN,QAAQ,QAAR,CAAf;AACA;AACA,MAAIO,SAAS,IAAIN,MAAJ,CAAW;AACtBO,WAAO;AACLC,YAAMC,MADD;AAELC,YAAM,IAFD;AAGLC,cAAQ,IAHH;AAILC,iBAAW,IAJN;AAKLC,gBAAU,IALL;AAMLC,iBAAW,CANN;AAOLC,WAAK,aAACC,CAAD,EAAO;AAAE,eAAOd,QAAQc,CAAR,CAAP;AAAmB,OAP5B;AAQLC,WAAK;AAAA,eAAKhB,QAAQe,CAAR,CAAL;AAAA;AARA,KADe;AAWtBE,cAAU,EAACV,MAAMW,OAAP,EAAgBN,UAAU,IAA1B,EAAgCO,SAAS,KAAzC,EAXY;AAYtBC,kBAAc,CAACZ,MAAD,CAZQ;AAatBa,qBAAiB,CAACb,MAAD,CAbK;AActBc,oBAAgB,EAACf,MAAMW,OAAP,EAAgBN,UAAU,IAA1B,EAAgCO,SAAS,KAAzC,EAdM;AAetBI,UAAM,EAAChB,MAAMV,SAASE,MAAT,CAAgByB,KAAhB,CAAsBC,MAA7B;AAfgB,GAAX,EAgBV,EAACC,YAAY,YAAb,EAhBU,CAAb;AAiBArB,SAAOsB,KAAP,CAAa,EAACrB,OAAO,CAAR,EAAb;AACA,MAAIsB,cAAJ;AACA,MAAI;AACF;AACAA,YAAQ/B,SAASgC,KAAT,CAAe,YAAf,CAAR;AACD,GAHD,CAGE,OAAOC,CAAP,EAAU;AACVF,YAAQ/B,SAASgC,KAAT,CAAe,YAAf,EAA6BxB,MAA7B,CAAR;AACD;AACD,SAAOuB,KAAP;AACD,CA7BD","file":"subscriber.js","sourcesContent":["'use strict'\n'use strict'\n\nvar mongoose = require('mongoose')\nvar Schema = mongoose.Schema\nconst {encrypt, decrypt} = require('../crypto')\nmodule.exports = function () {\n  const moment = require('moment')\n  // let moment = require('moment')\n  let schema = new Schema({\n    email: {\n      type: String,\n      trim: true,\n      unique: true,\n      lowercase: true,\n      required: true,\n      minLength: 1,\n      get: (v) => { return decrypt(v) },\n      set: v => encrypt(v)\n    },\n    verified: {type: Boolean, required: true, default: false},\n    subscribedTo: [String],\n    unsubscribeFrom: [String],\n    unsubscribeAll: {type: Boolean, required: true, default: false},\n    meta: {type: mongoose.Schema.Types.Object}\n  }, {collection: 'subscriber'})\n  schema.index({email: 1})\n  let Model\n  try {\n    // Throws an error if \"Name\" hasn't been registered\n    Model = mongoose.model('subscriber')\n  } catch (e) {\n    Model = mongoose.model('subscriber', schema)\n  }\n  return Model\n}\n"]}