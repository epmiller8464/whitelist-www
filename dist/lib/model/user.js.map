{"version":3,"sources":["../../../lib/model/user.js"],"names":["mongoose","require","bcrypt","moment","module","exports","Model","UserSchema","Schema","username","type","String","required","unique","createDate","Date","default","utc","email","trim","lowercase","minLength","match","pwd","verified","Boolean","flags","ip","whitelisted","role","history","Types","Object","meta","timestamps","createdAt","updatedAt","collection","index","pre","next","user","isModified","isNew","genSalt","error","salt","hash","methods","comparePassword","password","callback","compare","matches","model","e"],"mappings":"AAAA;;AACA,IAAIA,WAAWC,QAAQ,UAAR,CAAf;AACA,IAAMC,SAASD,QAAQ,QAAR,CAAf;AACA,IAAIE,SAASF,QAAQ,QAAR,GAAb;;AAEAG,OAAOC,OAAP,GAAiB,YAAY;AAC3B,MAAIC,cAAJ;;AAEA,MAAIC,aAAa,IAAIP,SAASQ,MAAb,CAAoB;AACnCC,cAAU,EAACC,MAAMC,MAAP,EAAeC,UAAU,IAAzB,EAA+BC,QAAQ,IAAvC,EADyB;AAEnCC,gBAAY,EAACJ,MAAMK,IAAP,EAAaH,UAAU,IAAvB,EAA6BI,SAASb,OAAOc,GAA7C,EAFuB;AAGnCC,WAAO;AACLR,YAAMC,MADD;AAELQ,YAAM,IAFD;AAGLC,iBAAW,IAHN;AAILR,gBAAU,KAJL;AAKLS,iBAAW,CALN;AAMLC,aAAO,YANF;AAOLT,cAAQ;AAPH,KAH4B;AAYnCU,SAAK,EAACb,MAAMC,MAAP,EAAeC,UAAU,IAAzB,EAZ8B;AAanCY,cAAU,EAACd,MAAMe,OAAP,EAAgBb,UAAU,IAA1B,EAAgCI,SAAS,KAAzC,EAbyB;AAcnCU,WAAO,CAACf,MAAD,CAd4B;AAenCgB,QAAI,CAAChB,MAAD,CAf+B;AAgBnCiB,iBAAaH,OAhBsB;AAiBnCI,UAAMlB,MAjB6B;AAkBnCD,UAAM,EAACA,MAAMC,MAAP,EAAeC,UAAU,IAAzB,EAlB6B;AAmBnCkB,aAAS,CAAC9B,SAASQ,MAAT,CAAgBuB,KAAhB,CAAsBC,MAAvB,CAnB0B;AAoBnCC,UAAM,EAACvB,MAAMV,SAASQ,MAAT,CAAgBuB,KAAhB,CAAsBC,MAA7B;AApB6B,GAApB,EAqBd,EAACE,YAAY,EAACC,WAAW,YAAZ,EAA0BC,WAAW,YAArC,EAAb,EArBc,EAqBoD,EAACC,YAAY,MAAb,EArBpD,CAAjB;;AAuBA9B,aAAW+B,KAAX,CAAiB,EAAC7B,UAAU,CAAX,EAAjB;AACAF,aAAW+B,KAAX,CAAiB,EAACpB,OAAO,CAAR,EAAjB;;AAEAX,aAAWgC,GAAX,CAAe,MAAf,EAAuB,UAAUC,IAAV,EAAgB;AACrC,QAAMC,OAAO,IAAb;AACA,QAAI,KAAKC,UAAL,CAAgB,UAAhB,KAA+B,KAAKC,KAAxC,EAA+C;AAC7CzC,aAAO0C,OAAP,CAAe,EAAf,EAAmB,UAACC,KAAD,EAAQC,IAAR,EAAiB;AAClC,YAAID,KAAJ,EAAW,OAAOL,KAAKK,KAAL,CAAP;AACX3C,eAAO6C,IAAP,CAAYN,KAAKlB,GAAjB,EAAsBuB,IAAtB,EAA4B,UAACD,KAAD,EAAQE,IAAR,EAAiB;AAC3C,cAAIF,KAAJ,EAAW,OAAOL,KAAKK,KAAL,CAAP;AACXJ,eAAKlB,GAAL,GAAWwB,IAAX;AACAP;AACD,SAJD;AAKD,OAPD;AAQD,KATD,MASO;AACL,aAAOA,MAAP;AACD;AACF,GAdD;;AAgBAjC,aAAWyC,OAAX,CAAmBC,eAAnB,GAAqC,UAAUC,QAAV,EAAoBC,QAApB,EAA8B;AACjEjD,WAAOkD,OAAP,CAAeF,QAAf,EAAyB,KAAK3B,GAA9B,EAAmC,UAACsB,KAAD,EAAQQ,OAAR,EAAoB;AACrD,UAAIR,KAAJ,EAAW,OAAOM,SAASN,KAAT,CAAP;AACXM,eAAS,IAAT,EAAeE,OAAf;AACD,KAHD;AAID,GALD;AAMA,MAAI;AACF;AACA/C,YAAQN,SAASsD,KAAT,CAAe,MAAf,CAAR;AACD,GAHD,CAGE,OAAOC,CAAP,EAAU;AACVjD,YAAQN,SAASsD,KAAT,CAAe,MAAf,EAAuB/C,UAAvB,CAAR;AACD;AACD,SAAOD,KAAP;AACD,CA1DD","file":"user.js","sourcesContent":["'use strict'\nvar mongoose = require('mongoose')\nconst bcrypt = require('bcrypt')\nlet moment = require('moment')()\n\nmodule.exports = function () {\n  let Model\n\n  let UserSchema = new mongoose.Schema({\n    username: {type: String, required: true, unique: true},\n    createDate: {type: Date, required: true, default: moment.utc},\n    email: {\n      type: String,\n      trim: true,\n      lowercase: true,\n      required: false,\n      minLength: 1,\n      match: /.+\\@.+\\..+/,\n      unique: true\n    },\n    pwd: {type: String, required: true},\n    verified: {type: Boolean, required: true, default: false},\n    flags: [String],\n    ip: [String],\n    whitelisted: Boolean,\n    role: String,\n    type: {type: String, required: true},\n    history: [mongoose.Schema.Types.Object],\n    meta: {type: mongoose.Schema.Types.Object}\n  }, {timestamps: {createdAt: 'created_at', updatedAt: 'updated_at'}}, {collection: 'user'})\n\n  UserSchema.index({username: 1})\n  UserSchema.index({email: 1})\n\n  UserSchema.pre('save', function (next) {\n    const user = this\n    if (this.isModified('password') || this.isNew) {\n      bcrypt.genSalt(10, (error, salt) => {\n        if (error) return next(error)\n        bcrypt.hash(user.pwd, salt, (error, hash) => {\n          if (error) return next(error)\n          user.pwd = hash\n          next()\n        })\n      })\n    } else {\n      return next()\n    }\n  })\n\n  UserSchema.methods.comparePassword = function (password, callback) {\n    bcrypt.compare(password, this.pwd, (error, matches) => {\n      if (error) return callback(error)\n      callback(null, matches)\n    })\n  }\n  try {\n    // Throws an error if \"Name\" hasn't been registered\n    Model = mongoose.model('user')\n  } catch (e) {\n    Model = mongoose.model('user', UserSchema)\n  }\n  return Model\n}\n"]}